//! MCP server implementation with macro-based routing
//!
//! This module contains the main server logic using the modern #[tool_router]
//! and #[tool_handler] macros for rmcp v0.8.1+ compatibility.

use anyhow::{Context, Result};
use rmcp::{
    ServerHandler, model::*, service::RequestContext, RoleServer,
    handler::server::router::tool::ToolRouter,
    tool, tool_handler, tool_router, schemars,
    ErrorData as McpError,
};
use serde::{Deserialize, Serialize};

/// Configuration for the MCP server
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    /// Server name
    pub name: String,
    /// Server version
    pub version: String,
    /// Enable debug mode
    pub debug: bool,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            name: "{project_name}".to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            debug: false,
        }
    }
}

/// Example tool request with structured parameters
#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]
pub struct ExampleToolRequest {
    /// Input parameter description
    pub input: String,
}

/// Main server implementation using macro-based routing
#[derive(Debug, Clone)]
pub struct {project_name_pascal}Server {
    config: ServerConfig,
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl {project_name_pascal}Server {
    /// Create a new server instance
    pub fn new() -> Self {
        Self {
            config: ServerConfig::default(),
            tool_router: Self::tool_router(),
        }
    }

    /// Example tool that demonstrates the macro-based pattern
    #[tool(description = "An example tool demonstrating macro-based routing")]
    async fn example_tool(
        &self,
        rmcp::handler::server::wrapper::Parameters(req): rmcp::handler::server::wrapper::Parameters<ExampleToolRequest>,
    ) -> Result<CallToolResult, McpError> {
        tracing::info!("Executing example_tool with input: {}", req.input);

        let result = format!("Processed input: {}", req.input);
        Ok(CallToolResult::success(vec![Content::text(result)]))
    }
}

/// Implement ServerHandler with macro support for tool and prompt routing
#[tool_handler]
impl ServerHandler for {project_name_pascal}Server {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: self.config.name.clone(),
                title: Some("{project_name} MCP Server".to_string()),
                version: self.config.version.clone(),
                website_url: None,
                icons: None,
            },
            instructions: Some(
                "A Model Context Protocol server for {project_name}".to_string(),
            ),
        }
    }
}

impl Default for {project_name_pascal}Server {
    fn default() -> Self {
        Self::new()
    }
}

/// Create and initialize the server
pub fn create_server() -> Result<{project_name_pascal}Server> {
    tracing::info!("Initializing {project_name} server");

    let server = {project_name_pascal}Server::new();

    tracing::info!(
        "Server initialized: {} v{}",
        server.config.name, server.config.version
    );

    Ok(server)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_server_creation() {
        let server = {project_name_pascal}Server::new();
        let info = server.get_info();
        assert_eq!(info.server_info.name, "{project_name}");
    }

    #[test]
    fn test_default_server() {
        let server = {project_name_pascal}Server::default();
        let info = server.get_info();
        assert!(!info.server_info.version.is_empty());
    }

    #[tokio::test]
    async fn test_example_tool() {
        let server = {project_name_pascal}Server::new();
        let req = ExampleToolRequest {
            input: "test input".to_string(),
        };

        // Note: Direct tool invocation requires tool_router context
        // In practice, tools are called through the MCP protocol
        let _server = server;
        assert_eq!(req.input, "test input");
    }
}
