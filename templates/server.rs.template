//! MCP server implementation
//!
//! This module contains the main server logic, initialization, and configuration.

use anyhow::{Context, Result};
use rmcp::server::Server;
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

use crate::resources::setup_resources;
use crate::tools::setup_tools;

/// Configuration for the MCP server
///
/// This struct holds all configuration options for the server.
/// It can be loaded from environment variables, configuration files,
/// or constructed programmatically.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    /// Server name
    pub name: String,

    /// Server version
    pub version: String,

    /// Maximum concurrent connections
    pub max_connections: usize,

    /// Request timeout in seconds
    pub timeout_secs: u64,

    /// Enable debug mode
    pub debug: bool,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            name: "{project_name}".to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            max_connections: 100,
            timeout_secs: 30,
            debug: false,
        }
    }
}

impl ServerConfig {
    /// Create a new server configuration
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the server name
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    /// Set the maximum number of concurrent connections
    pub fn with_max_connections(mut self, max: usize) -> Self {
        self.max_connections = max;
        self
    }

    /// Set the request timeout
    pub fn with_timeout(mut self, secs: u64) -> Self {
        self.timeout_secs = secs;
        self
    }

    /// Enable or disable debug mode
    pub fn with_debug(mut self, debug: bool) -> Self {
        self.debug = debug;
        self
    }

    /// Load configuration from environment variables
    ///
    /// Environment variables:
    /// - `MCP_SERVER_NAME`: Server name
    /// - `MCP_MAX_CONNECTIONS`: Maximum concurrent connections
    /// - `MCP_TIMEOUT_SECS`: Request timeout in seconds
    /// - `MCP_DEBUG`: Enable debug mode (true/false)
    pub fn from_env() -> Result<Self> {
        let mut config = Self::default();

        if let Ok(name) = std::env::var("MCP_SERVER_NAME") {
            config.name = name;
        }

        if let Ok(max_conn) = std::env::var("MCP_MAX_CONNECTIONS") {
            config.max_connections = max_conn
                .parse()
                .context("Invalid MCP_MAX_CONNECTIONS value")?;
        }

        if let Ok(timeout) = std::env::var("MCP_TIMEOUT_SECS") {
            config.timeout_secs = timeout.parse().context("Invalid MCP_TIMEOUT_SECS value")?;
        }

        if let Ok(debug) = std::env::var("MCP_DEBUG") {
            config.debug = debug.to_lowercase() == "true" || debug == "1";
        }

        Ok(config)
    }

    /// Validate the configuration
    pub fn validate(&self) -> Result<()> {
        if self.name.is_empty() {
            anyhow::bail!("Server name cannot be empty");
        }

        if self.max_connections == 0 {
            anyhow::bail!("Max connections must be greater than 0");
        }

        if self.timeout_secs == 0 {
            anyhow::bail!("Timeout must be greater than 0");
        }

        Ok(())
    }
}

/// Create and configure the MCP server
///
/// This function initializes the server with all tools and resources,
/// and returns a configured `Server` instance ready to accept connections.
///
/// # Errors
///
/// Returns an error if:
/// - Configuration is invalid
/// - Server initialization fails
/// - Tool or resource setup fails
pub fn create_server() -> Result<Server> {
    info!("Initializing MCP server");

    // Load configuration from environment or use defaults
    let config = ServerConfig::from_env().unwrap_or_default();

    // Validate configuration
    config
        .validate()
        .context("Invalid server configuration")?;

    debug!("Server configuration: {:?}", config);

    // Create the server builder
    let mut server = Server::new(&config.name, &config.version);

    // Set up server information
    server = server
        .with_server_info(
            &config.name,
            &config.version,
        )
        .context("Failed to set server info")?;

    // Register tools
    info!("Setting up tools");
    server = setup_tools(server).context("Failed to setup tools")?;

    // Register resources
    info!("Setting up resources");
    server = setup_resources(server).context("Failed to setup resources")?;

    info!(
        "Server initialized successfully: {} v{}",
        config.name, config.version
    );

    Ok(server)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = ServerConfig::default();
        assert_eq!(config.name, "{project_name}");
        assert!(!config.debug);
        assert!(config.max_connections > 0);
        assert!(config.timeout_secs > 0);
    }

    #[test]
    fn test_config_builder() {
        let config = ServerConfig::new()
            .with_name("test-server")
            .with_max_connections(50)
            .with_timeout(60)
            .with_debug(true);

        assert_eq!(config.name, "test-server");
        assert_eq!(config.max_connections, 50);
        assert_eq!(config.timeout_secs, 60);
        assert!(config.debug);
    }

    #[test]
    fn test_config_validation() {
        let valid_config = ServerConfig::default();
        assert!(valid_config.validate().is_ok());

        let invalid_config = ServerConfig {
            name: "".to_string(),
            ..Default::default()
        };
        assert!(invalid_config.validate().is_err());

        let invalid_config = ServerConfig {
            max_connections: 0,
            ..Default::default()
        };
        assert!(invalid_config.validate().is_err());
    }

    #[test]
    fn test_create_server() {
        let result = create_server();
        assert!(result.is_ok(), "Server creation should succeed");
    }
}
